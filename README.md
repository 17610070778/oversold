## 使用mysql的行级锁来解决并发超卖问题
### 说明：首先通过查询语句对当前数据进行加行级锁，然后再修改数据库-1
### 加锁比较
* 使用S(共享锁)锁加锁：容易产生死锁问题，原因分析：假如S1线程进行了加共享锁之后，还没来得及修改数据，此时S2线程也进行了加共享锁(当被加共享锁时，还可以被其他线程加共享锁)，此时S2线程需要S1线程修改数据释放锁才能修改数据，而S1线程也需要S2线程修改数据释放锁后再修改数据，因此产生死锁；
* 使用X(排他锁)锁加锁：楼主使用排他锁200线程并发访问，并没有发现死锁的发生；
